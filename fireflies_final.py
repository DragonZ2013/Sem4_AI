# -*- coding: utf-8 -*-
"""Fireflies Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xc_QwvAUyDuyhdZ58LniX4aEhYVTEK1t
"""

import random
import math
import matplotlib.pyplot as plt

ffCount = 150             #nr licurici
L = 50                    #Durata ciclu on+off
rL = 1400                    #Raza cercului licuriciului
points=[]                 #Coordonatele licuriciului
inRange = []              #lista cu vecinii
time = []                 #perioada de timp care contine o lista de doua elemente, time[index][0] = cat timp sta aprins, time[index][1] = cat timp sta stins
glowsBool = []            #Lista de bool, tine minte daca e on sau off licuriciul
glowTime = []             #cat timp mai are din ciclul de on sau off in care e
chance = 40               #sansa sa fie on licuriciul
numberOfIterations = 5000 
nrOfLoops = 50

def randBool(percent):
    return random.randrange(100) < percent

def randomValues():
  for i in range(ffCount):                          
    time.append([L//2,L//2])
    glowsBool.append(randBool(chance))
    if(glowsBool[i]):
      glowTime.append(random.randint(0,L//2))
    else:
      glowTime.append(random.randint(0,L//2))

def randomPoints():
  for i in range(ffCount):
    x = random.randint(0,1000)
    y = random.randint(0,1000)
    points.append([x,y])

def calculateDistance(x1,y1,x2,y2):
  return math.hypot(x1 - x2, y1 - y2)

def fireflyInRange(r):                             #calculeaza pentru fiecare licurici, indexul vecinilor 
  for i in range(len(points)):
    neighbours = [];
    for j in range(len(points)):
      if i != j:
        if calculateDistance(points[i][0], points[i][1], points[j][0], points[j][1]) < r:
          neighbours.append(j)                    #ii pune in lista lui de vecini daca il vede
    inRange.append(neighbours)                    #lista de lista de vecini

def passOneUnitTime():
  for ffIndex in range(ffCount):                    #pentru fiecare licurici in parte
    if glowTime[ffIndex] == 0:                      #daca e gata ciclul de on/off
      if glowsBool[ffIndex]:                        #daca el stralucea
        glowTime[ffIndex] = time[ffIndex][1]        #ii dam timpul pentru stins
        glowsBool[ffIndex] = False                  #il mutam ca nu straluceste
      else:                                         #fix invers
        glowTime[ffIndex] = time[ffIndex][0]
        glowsBool[ffIndex] = True
      
    if glowsBool[ffIndex]:                          #daca e aprins
      on = 0;
      off = 0;
      for neighbourIndex in inRange[ffIndex]:       #lista de vecini | inRange[index] = lista cu vecinii indexului
        if(glowsBool[neighbourIndex]):              #contorizeaza vecinii aprinsi si stinsi  
          on += 1;
        else:
          off += 1;
      if on < off and time[ffIndex][0] == L//2:     #daca are mai multi stinsi si ciclul e de L/2 il scade
        time[ffIndex][0] -= 1
      elif on >= off and time[ffIndex][0] == L//2-1 and glowsBool[ffIndex]==True:  #daca are mai multi aprinsi si ciclul e de L/2-1 il creste la loc
        time[ffIndex][0] += 1
    glowTime[ffIndex] -= 1                          #ii scade din ciclul licuriciului
        
    

randomPoints()
randomValues()
fireflyInRange(rL)
x_plot=[]
y_plot=[]



for x in range(numberOfIterations):                 #nr de iteratii
  passOneUnitTime()
  x_plot.append(x)
  y_plot.append(sum(glowsBool))                     #sum(glowsBool) returneaza cati sunt aprinsi
    
plt.plot(x_plot,y_plot,'r')
plt.show()

#TEIL B
averageSum = []
x_plotD=[]
y_plotD=[] 
for r in range(25, 1426, 25):
  r /= 1000
  x_plotD.append(r)
  averageSum.append(0)

for x in range(nrOfLoops):
  points=[]
  time = []            
  glowsBool = []            
  glowTime = []  
  randomPoints()
  randomValues()
  timeInitialValue = time.copy()             
  glowsBoolInitialValue = glowsBool.copy()             
  glowTimeInitialValue = glowTime.copy()
  index = 0
  min = ffCount + 1
  max = -1          
  for r in range(25, 1426, 25):
    #r /= 100
    min=ffCount+1
    max=-1
    inRange = []
    fireflyInRange(r)
    time = timeInitialValue.copy()             
    glowsBool = glowsBoolInitialValue.copy()             
    glowTime = glowTimeInitialValue.copy()  
    for i in range(numberOfIterations-L):
      passOneUnitTime()
    #print(glowsBool)
    for i in range(L):
      ffOn = sum(glowsBool)
      #print(ffOn)
      if(ffOn > max):
        max = ffOn
      if(ffOn < min):
        min = ffOn
      passOneUnitTime()
    #print(str(x)+": "+str(r)+": "+str(min)+" "+ str(max)+"\n\n")
    averageSum[index] += (max-min)/2
    index+=1

for i in range(len(averageSum)):
  y_plotD.append(averageSum[i] / nrOfLoops)

plt.plot(x_plotD,y_plotD,'r')
plt.show()

#get values for current loop
max=-1
min=151
for i in range(100):
      ffOn = sum(glowsBool)
      #print(ffOn)
      if(ffOn > max):
        max = ffOn
      if(ffOn < min):
        min = ffOn
      passOneUnitTime()
print(min)
print(max)