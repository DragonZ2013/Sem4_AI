# -*- coding: utf-8 -*-
"""Ant Salesman Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LR2qT1sb26j5JG23l7Mmpssm9nfRYgD5
"""

E = [[0, 0], [0, 1], [1, 0], [1, 1]]

def generatePheromones(listPoints):
  pheromones = []
  for i in range(len(listPoints)):
    pheromones.append([])
    for j in range(len(listPoints)):
      pheromones[i].append(0)
  return pheromones

print(generatePheromones(E))

E = [[0, 0], [0, 1], [1, 0], [1, 1]]

def generateDistances(listPoints):
  distances = []
  for i in range(len(listPoints)):
    distances.append([])
    for j in range(len(listPoints)):
      distances[i].append(calc_distance(listPoints[i][0], listPoints[i][1], listPoints[j][0], listPoints[j][1]))
  return distances

print(generateDistances(E))

import math

def calc_distance(x1,y1,x2,y2):
  return math.hypot(x1 - x2, y1 - y2)

points=[]
for i in range(0,25):
  points.append([0,i*4])

for i in range(0,25):
  points.append([i*4,100])
  
for i in range(0,25):
  points.append([100,i*4])
  
for i in range(0,25):
  points.append([i*4,0])

#returns a list of probabilities which edge the ant will follow
def generateProbabilities(currentPoint, remainingPoints):
  probabilities = []
  sumTot = 0
  for i in range(len(points)):
    if i in remainingPoints and i != currentPoint:
      prob = pheromones[currentPoint][i] ** a * (1/distances[currentPoint][i])**b
      probabilities.append(prob)
      sumTot += prob
    else: probabilities.append(0)
  for i in range(len(points)):
    probabilities[i] = probabilities[i] / sumTot
  return probabilities

toBeVisited = [i for i in range(len(points))]
toBeVisited.remove(ants[0])
print(generateProbabilities(ants[0], toBeVisited))

def decayPheromones():
  for i in range(len(pheromones)):
    for j in range(len(pheromones)):
      pheromones[i][j] = (1-p) * (pheromones[i][j])

def setPheromones(route, routeDistance):
  for i in range(len(route)-1):
      pheromones[route[i]][route[i+1]] = (pheromones[route[i]][route[i+1]]) + (Q / routeDistance)

def generateRoute(antStartingCity):
  visited = [antStartingCity]
  toBeVisited = [i for i in range(len(points))]
  toBeVisited.remove(antStartingCity)
  currentCity = antStartingCity
  while toBeVisited != []:
    probabilities = generateProbabilities(currentCity, toBeVisited)
    chance = random.uniform(0, 1)
    i = 0
    s = 0
    while s < chance:
      s += probabilities[toBeVisited[i]]
      i += 1
    i -= 1
    visited.append(toBeVisited[i])
    currentCity = toBeVisited[i]
    toBeVisited.remove(toBeVisited[i])
  return visited

print(generateRoute(ants[0]))

24/6.097560975609756e-05

import math
import random
import sys
import matplotlib.pyplot as plt

def calc_distance(x1,y1,x2,y2):
  return math.hypot(x1 - x2, y1 - y2)

#generate points in a square
#points=[]
#for i in range(0,25):
  #points.append([0,i*4])

#for i in range(1,24):
  #points.append([i*4,100])
  
#for i in range(0,25):
  #points.append([100,i*4])
  
#for i in range(1,24):
  #points.append([i*4,0])

#variables for easy changes
# a = concentration of pheromones
# b = range of view
# p = (1-p) for decay rate
# Q = Q/weight
# pointcount = nr of cities
pointcount = 100
a = 2
b = 3
p = 0.1
Q = 1000

points = []

for i in range(pointcount):
  x = random.randint(0,100)
  y = random.randint(0,100)
  while [x,y] in points:
    x = random.randint(0,100)
    y = random.randint(0,100)
  points.append([x,y])


#generate weighted adjMatrix (weight=length of edge)
def generateDistances(listPoints):
  distances = []
  for i in range(len(listPoints)):
    distances.append([])
    for j in range(len(listPoints)):
      distances[i].append(calc_distance(listPoints[i][0], listPoints[i][1], listPoints[j][0], listPoints[j][1]))
  return distances
  
distances = generateDistances(points)
#print(distances)

#initialize weighted adjMatrix with 1 (weight=phCount)
def generatePheromones(listPoints):
  pheromones = []
  for i in range(len(listPoints)):
    pheromones.append([])
    for j in range(len(listPoints)):
      pheromones[i].append(1)
  return pheromones
  
pheromones = generatePheromones(points)

#returns a list of probabilities which edge the ant will follow
def generateProbabilities(currentPoint, remainingPoints):
  probabilities = []
  sumTot = 0
  for i in range(len(points)):
    if i in remainingPoints and i != currentPoint:
      prob = pheromones[currentPoint][i] ** a * (1/distances[currentPoint][i])**b
      probabilities.append(prob)
      sumTot += prob
    else: probabilities.append(0)
  #if sumTot==0:
    #print(currentPoint)
    #print(i)
    #print(pheromones[currentPoint])
    #print(distances[currentPoint])
  for i in range(len(points)):
    probabilities[i] = probabilities[i] / sumTot
  return probabilities

def generateRoute(antStartingCity):
  visited = [antStartingCity]
  toBeVisited = [i for i in range(len(points))]
  toBeVisited.remove(antStartingCity)
  currentCity = antStartingCity
  while toBeVisited != []:
    probabilities = generateProbabilities(currentCity, toBeVisited)
    chance = random.uniform(0, 1)
    i = 0
    s = 0
    while s < chance:
      s += probabilities[toBeVisited[i]]
      i += 1
    i -= 1
    visited.append(toBeVisited[i])
    currentCity = toBeVisited[i]
    toBeVisited.remove(toBeVisited[i])
  return visited

def decayPheromones():
  for i in range(len(pheromones)):
    for j in range(len(pheromones)):
      pheromones[i][j] = (1-p) * (pheromones[i][j])

#increases pheromons according to performance
def setPheromones(route, routeDistance):
  for i in range(len(route)-1):
      pheromones[route[i]][route[i+1]] = (pheromones[route[i]][route[i+1]]) + (Q / routeDistance)

def generationalColony(anzAnts, nrGenerations):
  ants = []
  for i in range(anzAnts):
      randomPoint = random.randint(0,len(points))
      ants.append(randomPoint)
  currentGen = 0
  globalMin = [[], sys.maxsize]
  while currentGen <= nrGenerations:

    minRoute = [[], sys.maxsize]
    antRoutes = []

    for i in range(len(ants)):
      antRoutes.append(generateRoute(ants[i]))

    decayPheromones()
    for routes in antRoutes:
      s = 0
      #print(routes)
      for i in range(len(routes)-1):
        #print(distances[i][i+1])
        s += distances[routes[i]][routes[i+1]]
      s += distances[routes[-1]][routes[0]]
      setPheromones(routes,s)
      #print(s)
    if s < globalMin[1]:
      globalMin[0] = routes
      minRoute[0] = routes
      globalMin[1] = s
      minRoute[1] = s
      #print("changedGlobal", s)
      #print(currentGen)
      #for i in range(len(points)):
      #  plt.plot(points[i][0],points[i][1],markersize=3, marker="o")
      #x_plot=[]
      #y_plot=[]
      #for i in range(len(points)):
      #  x_plot.append(points[globalMin[0][i]][0])
      #  y_plot.append(points[globalMin[0][i]][1])
      #x_plot.append(points[globalMin[0][0]][0])
      #y_plot.append(points[globalMin[0][0]][1])
      #plt.plot(x_plot,y_plot,'r')
      #plt.show()

    
    else:
      if s < minRoute[1]:
        minRoute[0] = routes
        minRoute[1] = s
        #print("changedLocal", s)
    
    if currentGen%500==0 or currentGen==0:
      print("Current generation: "+str(currentGen))
      for i in range(len(points)):
        plt.plot(points[i][0],points[i][1],markersize=3, marker="o")
      x_plot=[]
      y_plot=[]
      for i in range(len(points)):
        x_plot.append(points[globalMin[0][i]][0])
        y_plot.append(points[globalMin[0][i]][1])
      x_plot.append(points[globalMin[0][0]][0])
      y_plot.append(points[globalMin[0][0]][1])
      plt.plot(x_plot,y_plot,'r')
      plt.show()
    

    #print(minRoute[1])
    currentGen += 1

  print("Final Distance: ", globalMin[1])

  
generationalColony(5, 2000)

print((((1/1150315)**50)*(0.01)**10)**1)